{"meta":{"title":"Mamba's Blog","subtitle":"技术改变生活","description":"I do what I do.—Kobe Bryant","author":"秃头东","url":"https://github.com/Mamba243/Mamba243.github.io.git","root":"/"},"pages":[{"title":"关于","date":"2020-03-16T03:07:13.000Z","updated":"2020-03-16T11:22:58.627Z","comments":true,"path":"about/index.html","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/about/index.html","excerpt":"","text":"关于我 科密 关于本站 自我记录"},{"title":"sitemap","date":"2020-03-16T03:08:17.000Z","updated":"2020-03-16T03:08:17.610Z","comments":true,"path":"sitemap/index.html","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/sitemap/index.html","excerpt":"","text":""},{"title":"2020年历","date":"2020-03-16T03:07:56.000Z","updated":"2020-03-16T13:13:30.259Z","comments":true,"path":"schedule/index.html","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/schedule/index.html","excerpt":"","text":""},{"title":"categories","date":"2020-03-16T03:07:37.000Z","updated":"2020-03-16T12:19:28.662Z","comments":true,"path":"categories/index.html","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-03-16T03:06:11.000Z","updated":"2020-03-16T12:18:19.614Z","comments":true,"path":"tags/index.html","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"final关键字","slug":"final关键字","date":"2020-04-13T03:57:25.914Z","updated":"2020-04-13T03:52:30.484Z","comments":true,"path":"2020/04/13/final关键字/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/04/13/final%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"final 关键字 final关键字代表最终、不可改变的。常见四种用法:1.可以用来修饰一个类2.可以用来修饰一个方法3.还可以用来修饰一个局部变量，4.还可以用来修饰一个成员变量 final关键字用来修饰类的时候 格式: 123public final class 类名称&#123;// ...&#125; 含义:当前这个类不能有任何的子类。(太监类 ) 注意：一个类如果是final的，那么其中所有的成员方法都无法覆盖重写（因为没有儿子） final修饰成员方法当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。 格式 123修饰符final. 返回值类型方法名称(参数列表) &#123;//方法体&#125; 12345public class Fu &#123;public final void method() &#123;System. out . println(\"父类方法执行! \"); &#125;&#125; 注意事项： 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 public abstract /*final*/ void methodAbs( ); final不能覆盖重写，而抽象方法abstract必须覆盖重写，自相矛盾","text":"final 关键字 final关键字代表最终、不可改变的。常见四种用法:1.可以用来修饰一个类2.可以用来修饰一个方法3.还可以用来修饰一个局部变量，4.还可以用来修饰一个成员变量 final关键字用来修饰类的时候 格式: 123public final class 类名称&#123;// ...&#125; 含义:当前这个类不能有任何的子类。(太监类 ) 注意：一个类如果是final的，那么其中所有的成员方法都无法覆盖重写（因为没有儿子） final修饰成员方法当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。 格式 123修饰符final. 返回值类型方法名称(参数列表) &#123;//方法体&#125; 12345public class Fu &#123;public final void method() &#123;System. out . println(\"父类方法执行! \"); &#125;&#125; 注意事项： 对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。 public abstract /*final*/ void methodAbs( ); final不能覆盖重写，而抽象方法abstract必须覆盖重写，自相矛盾 final关键字修饰局别变量 一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。一次赋值，终生不变 例如： 123456789final int num2 = 200;System . out . println(num2); // 200num2 = 250; //. 错误写法!不能改变!num2 = 200; //错误写法! final int num3;num3 = 30; //正确写法!只要保证有唯一一次赋值即可 对于基本类型来说，不可变说的是变量当中的数据不可改变 对于引用类型来说，不可变说的是变量当中的地址值不可改变 1234567891011121314151617Student stu1 = new Student( name: \"赵丽颖\");System. out . println(stu1);System . out . print1n(stu1. getName()); //赵丽颖stu1 = new Student( name: \"霍建华\"); .System.out . println(stu1);System . out . println(stu1. getName()); //霍建华System. out . println(\"=============\");final Student stu2 = new Student( name:“高圆圆\");//错误写法! final的引用类型变量， 其中的地址不可改变stu2=new Student( name:\"赵又廷\"); final Student stu2 = new Student( name:“高圆圆\");stu2. setName(\"高圆圆圆圆圆圆\");System. out . println(stu2. getName()); //高圆圆圆圆圆圆 地址值不可以改变，但是里面的内容可以发生改变 ，改成高圆圆圆圆圆圆 final关键字修饰成员变量 对于成员变量来说，如果使用final关键宇修饰，那么这个变量也照样是不可变。 1.由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。 2.对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一 。 3.必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。 1234567891011121314public class Person &#123;private. final string. name = \"鹿晗\"; //直接赋值public Person() &#123;&#125;public Person(String name) &#123;this.name = name; //会报错，前面已经赋值，这里就不能再用构造方法赋值&#125;public String getName() &#123;return name ;&#125;public void setName(String name) &#123;this. name = name; //会报错，前面已经直接赋值&#125;&#125; 可以改成这样：（通过构造进行赋值） 123456789101112131415public class Person &#123;private. final string. name;public Person() &#123; name = \"鹿晗\"&#125;public Person(String name) &#123;this.name = name; &#125;public String getName() &#123;return name ;&#125;//public void setName(String name) &#123;//this. name = name; setter方法得注释掉 不能再改了//&#125;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"权限修饰符","slug":"权限修饰符","date":"2020-04-13T03:57:25.907Z","updated":"2020-04-13T03:52:49.668Z","comments":true,"path":"2020/04/13/权限修饰符/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/04/13/%E6%9D%83%E9%99%90%E4%BF%AE%E9%A5%B0%E7%AC%A6/","excerpt":"权限修饰符 java中有4种权限修饰符： public protected default private 同一个类(我自己) Yes Yes Yes Yes 同一个包(我邻居) Yes Yes Yes No 不同包子类(我儿子) Yes Yes No No 不同包非子类(陌生人) Yes No No No","text":"权限修饰符 java中有4种权限修饰符： public protected default private 同一个类(我自己) Yes Yes Yes Yes 同一个包(我邻居) Yes Yes Yes No 不同包子类(我儿子) Yes Yes No No 不同包非子类(陌生人) Yes No No No 同一个类的情况1234567package cn. itcast . day11. demo02;public class MyClass &#123;private int num = 10;public void method() &#123;System . out . println(num);&#125;&#125; 这里的num用的是private修饰，因为method是自己类的方法，可以访问 同理，public/protected/或者default(不写)都可以访问num 同一个包的情况1234567package cn. itcast . day11. demo02;public class MyClass &#123;private int num = 10;public void method() &#123;System . out . println(num);&#125;&#125; 另一个类： 123456package cn. itcast . day11. demo02;public class MyAnother &#123;public void anotherMethod() &#123;System . out .print1n(new MyClass() . num) ;&#125;&#125; 这里的num用的是private修饰，因为another method是同包不同类的方法，不可以访问 只有public/protected/或者default(不写)可以访问num 不同包子类的情况1234567package cn. itcast . day11. demo02;public class MyClass &#123;private int num = 10;public void method() &#123;System . out . println(num);&#125;&#125; 另一个包下的类 1234567package cn. itcast . day11. demo02. sub;import cn. itcast. day11. demo02.MyClass ;public c1ass MySon extends MyClass &#123;public void methodSon() &#123;System. out . print1n(super . num) ;&#125;&#125; 这里的num用的是private修饰，因为methodSon是不同包不同类的方法，不可以访问 只有public/protected可以访问num 不同包非子类的情况1234567package cn. itcast . day11. demo02;public class MyClass &#123;private int num = 10;public void method() &#123;System . out . println(num);&#125;&#125; 完全不同包有非子类关系： 1234567package cn. itcast . day11. demo02. sub;import cn. itcast. day11. demo02.MyClass ;public class Stranger &#123;public void methodStrange() &#123;System . out . print1n(new MyClass() . num) ;&#125;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"内部类","slug":"内部类的概念和分类","date":"2020-04-13T03:57:25.901Z","updated":"2020-04-13T03:52:58.790Z","comments":true,"path":"2020/04/13/内部类的概念和分类/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/04/13/%E5%86%85%E9%83%A8%E7%B1%BB%E7%9A%84%E6%A6%82%E5%BF%B5%E5%92%8C%E5%88%86%E7%B1%BB/","excerpt":"内部类的概念和分类 如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类 例如：身体的心脏的关系 ​ 汽车和发动机的关系 分类 成员内部类 局部内部类(包含匿名内部类) 定义成员内部类格式 修饰符 class （外部）类名称{ ​ 修饰符 class （内部）类名称{ ​ } } 注意：内用外，可以随意访问；外用内，一定需要借助内部类对象。","text":"内部类的概念和分类 如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类 例如：身体的心脏的关系 ​ 汽车和发动机的关系 分类 成员内部类 局部内部类(包含匿名内部类) 定义成员内部类格式 修饰符 class （外部）类名称{ ​ 修饰符 class （内部）类名称{ ​ } } 注意：内用外，可以随意访问；外用内，一定需要借助内部类对象。 代码演示 1234567891011121314151617181920212223public class Body &#123; //外部类 public class Heart &#123; //成员内部类 //内部类的方法 public void beat() &#123; System. out . println(\"心脏跳动:蹦蹦蹦! \"); //正确写法! System. out . println(\"我叫: \" + name); // 内部类可以随意访问外部 &#125; //外部类的成员变量 private String name; //外部类的方法public void methodBody() &#123; System . out . print1n( \"外部类的方法\");&#125;public String getName() &#123; return name ;&#125;public void setName(String name) &#123; this. name = name; &#125;&#125;&#125; 成员内部类的使用 1.间接方式:在外部类的方法当中，使用内部类:然后main只是调用外部类的方法。 main 调用外部，外部调用内部，从而实现main调用内部 1234567891011121314public class Body &#123; //外部类 public class Heart &#123; //成员内部类 //内部类的方法 public void beat() &#123; System. out . println(\"心脏跳动:蹦蹦蹦! \"); &#125; //外部类的方法 public void methodBody() &#123; Heart heart = new Heart(); heart.beat(); &#125; &#125;&#125; 主类运行： 1234567public class Demo01InnerClass &#123; public static void main(String[] args) &#123; Body body = new Body(); //外部类的对象//通过外部类的对象，调用外部类的方法，里面间接在使用内部类Heart body.methodBody(); &#125;&#125; 2 直接方式：公式 类名称 对象名 = new 类名称（）； 外部类名称.内部类名称 对象名 = new 外部类名称（）.new内部类名称（）； 12Body .Heart heart = new Body() . new Heart( );heart.beat(); 内部类的同名变量访问 如果出现重名，怎么访问外部类的成员变量？ 格式： 外部类名称.this.变量名 123456789101112package cn. itcast . day11. demo03;public class Outer &#123; int num = 10; //外部类的成员变量 public class Inner&#123; int num = 20; //内部类的成员变量 public void methodInner() &#123; int num = 30; //内部类方法的局部变量 System.out.println(num); //局部变量，就近原则 System.out.println(this.num); System.out.println(Outer.this.num); &#125;&#125; 局部内部类定义 如果一个类是定义在一个方法内部的，那么这就是一 个局部内部类。“局部”只有当前所属的方法才能使用它，出了这个方法外面就不能用了。 定义格式:修饰符class外部类名称{修饰符返回值类型外部类方法名称(参数列表) {class局部内部类名称{}} 类放在方法里面 123456789public c1ass Outer &#123; public void pethodouter() &#123; class Inher &#123; //局部内部类 intnum=10;. public void methodInner() &#123; System. out. println(num); // 10 &#125; &#125;&#125; 如何调用这个局部内部类？ 123456789101112public class Outer &#123; public void methodOuter() &#123; class Inner &#123; //局部内部类 int num = 10; public void methodInner() &#123; System. out . print1n(num); // 10 &#125; &#125; Inner inner = new Inner(); //这两排调用局部方法必须在methodOuter里面编写 inner . methodInner(); &#125;&#125; 权限修饰符在不同的类中是使用public &gt; protected &gt; (default) &gt; private :定义一个类的时候，权限修饰符规则: 1.外部类: public / (default)2.成员内部类: public / protected / (default) / private3.局部内部类: 什么都不能写 局部内部类的final问题局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是[有效final的]。 12345678910111213package cn.1tcast. day1l. demob4jpublic class MyOuter &#123; public void methodOuter() &#123; int num = 10; //所在方法的局部变量 num = 20; class MyInner &#123; public void methodInner() &#123; System. out . print1n(num) ; &#125; &#125; &#125;&#125; 这样就会报错，num不可再更改 可以final int num =10,也可以省略final,但是不可以改，省略了也不可以改，改就错 匿名内部类 如果接口的实现类(或者是父类的子类)只需要使用唯一-的一次,那么这种情况下就可以省略掉该类的定义，而改为使用[匿名内部类]。匿名内部类的定义格式:接口名称_对象名二new.接口名称() {//覆盖重写所有抽象方法}; 代码举例 定义一个接口 1234package cn. itcast . day11. demo05 ;public interface MyInterface &#123;void method(); //抽象方法&#125; main: 12345678910111213141516public class DemoMain &#123;public static void main(String[] args) &#123;// MyInterface obj = new MyInterfaceImpl();// obj.method(); // MyInterface some = new MyInterface(); //错误写法!//使用匿名内部类MyInterface obj = new MyInterface() &#123; @Override public void method() &#123; System . out . println( \"匿名内部类实现了方法! \"); &#125; &#125;; obj.method(); //会输出 匿名内部类实现了方法! &#125;&#125; 总结： 这个匿名内部类就顶替了我们之前写接口时的所需要写的实现类 因为我们之前说过，要想使用接口，必须要有实现类，并且实现类需要override所有的抽象方法，然后再再main方法中调用他，显然这是很复杂而且很多余的 因此，如果我们有匿名内部类的话，我们就可以直接顶替掉之前的写法，直接就可以用了，这样是很方便很简单的，十分有用","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"特殊成员变量","slug":"特殊的成员变量","date":"2020-04-13T03:57:25.895Z","updated":"2020-04-13T03:53:19.268Z","comments":true,"path":"2020/04/13/特殊的成员变量/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/04/13/%E7%89%B9%E6%AE%8A%E7%9A%84%E6%88%90%E5%91%98%E5%8F%98%E9%87%8F/","excerpt":"特殊的成员变量如何用类成员作为游戏变量定义一个剑类： 1234567891011121314package cn. itcast . day11. demo06;public class Weapon &#123; private String code; //武器的代号public Weapon() &#123;&#125;public Weapon(String code) &#123; this.code = code;&#125;public String getCode() &#123;return code;&#125;public void setCode(String code) &#123;this.code = code;&#125;","text":"特殊的成员变量如何用类成员作为游戏变量定义一个剑类： 1234567891011121314package cn. itcast . day11. demo06;public class Weapon &#123; private String code; //武器的代号public Weapon() &#123;&#125;public Weapon(String code) &#123; this.code = code;&#125;public String getCode() &#123;return code;&#125;public void setCode(String code) &#123;this.code = code;&#125; 定义一个英雄类： 1234567891011121314151617181920212223242526272829303132333435//游戏当中的英雄角色类pub1ic class Hero &#123;private String name; //. 英雄的名字private int age; //英雄的年龄private Neapon weapon; //英雄的武器public Hero() &#123;public Hero(String name, int age, Weapon weapon) &#123;this.name = name ;this.age = age;this .weapon = weapon;&#125; public void attack() &#123;System.out.println(\"年龄为\" + age + \"的\" + name + \"用\" weapon. getCode() + \"攻击敌方。\");public String getName() &#123;return name ;&#125;public void setName(String name) &#123;this. name = name;&#125;public int getAge() &#123;return age;&#125;public void setAge(int age) &#123;this.age = age;&#125;public Weapon getWeapon() &#123;return weapon;&#125;public void setWeapon(Weapon weapcn) &#123;this . weapon = weapon;&#125;&#125;&#125; 主方法运行一下： 123456789101112131415package cn. itcast . day11.demo06;public class DemoMain &#123;public static void main(String[] args) &#123;//创建一个英雄角色Hero hero = new Hero();//为英雄起一个名字，并且设置年龄hero. setName(\"盖伦\");hero. setAge(20);//创建一个武器对象Weapon weapon = new Weapon( code: “多兰剑\");//为英雄配备武器hero. setWeapon(weapon);hero. attack();&#125;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"object类","slug":"Object 类","date":"2020-04-13T03:57:25.887Z","updated":"2020-04-13T03:53:51.252Z","comments":true,"path":"2020/04/13/Object 类/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/04/13/Object%20%E7%B1%BB/","excerpt":"Object 类 object类是所有类的父类，是java中最基层的类 因此在继承的时候可以省略extends object object类常用的几种方法 getClass()方法 返回对象执行时的class实例 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; object[] arr = new object[4]; arr[0] = new object(); arr[1] = new String(\"字符串\"); arr[2] = new Integer(10); arr[3] = new Demo(); for(object obj:arr)&#123; System . out . print1n(obj.getClass()); &#125; &#125;&#125; 执行结果： class java. lang. objectclass java. lang. String .class java. lang. Integerclass Demo 返回了我这个对象是全名","text":"Object 类 object类是所有类的父类，是java中最基层的类 因此在继承的时候可以省略extends object object类常用的几种方法 getClass()方法 返回对象执行时的class实例 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; object[] arr = new object[4]; arr[0] = new object(); arr[1] = new String(\"字符串\"); arr[2] = new Integer(10); arr[3] = new Demo(); for(object obj:arr)&#123; System . out . print1n(obj.getClass()); &#125; &#125;&#125; 执行结果： class java. lang. objectclass java. lang. String .class java. lang. Integerclass Demo 返回了我这个对象是全名 toString（）方法 将对象返回为字符串形式 12345for(object obj:arr)&#123; System . out . print1n(obj.toString()); &#125; &#125;&#125; 执行结果： java .lang . object@1db9742字符串10Demo@106d69c 如果我们不写.toString()方法，也会自动调用该方法， 例如System . out . print1n(obj); equals（）方法 比较两个对象是否相等 12345678910111213public class Demo &#123; public static void main(String[] args) &#123; object[] arr = new object[4]; arr[0] = new object(); arr[1] = new Demo(); arr[2] = arr[0]; arr[3] = new object(); System . out . print1n(arr[0].equals(arr[1])); //false System . out . print1n(arr[0].equals(arr[2])); //true System . out . print1n(arr[0].equals(arr[3])); //false &#125;&#125; 实例：(检测是否是同一个人)person类 123456789101112public class Person 1&#123; String name ; String id; @Override public boolean equals(object obj) &#123; Person p = (Person) obj; boolean b1 = this. name.equals(p. name); boolean b2 = this.id.equals(p.id); return b1 &amp;&amp; b2; &#125;&#125; 主类 1234567891011121314151617181920212223public class Demo &#123; public static void main(String[] args) &#123; Person p1 = new Person(); Person p2 = new Person(); Person p3 = new Person(); Person p4 = new Person(); p1. name=\"小明\"; p1. id= \"123\"; p2. name=\"小红\"; p2. id=\"123\"; p3. name=\"小明\"; p3. id= \"456\"; p4. name=\"小明\"; p4. id= \"123\"; System. out . print1n(p1. equals(p2)); //false System. out . print1n(p2. equals(p3)); //false System. out . print1n(p1. equals(P3)); //false System. out . print1n(p1. equals(P4)); //true System. out . print1n(p1==p4); //false &#125; &#125; java中equals和==的区别​ 参考文献","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"多态","slug":"多态","date":"2020-04-13T03:57:25.880Z","updated":"2020-04-13T03:52:17.551Z","comments":true,"path":"2020/04/13/多态/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/04/13/%E5%A4%9A%E6%80%81/","excerpt":"多态 多态的格式和使用代码当中体现多态性，其实就是一句话: 父类引用指向子类对象。格式：父类名称 对象名= new 子类名称();或者:接口名称对象名= new实现类名称();","text":"多态 多态的格式和使用代码当中体现多态性，其实就是一句话: 父类引用指向子类对象。格式：父类名称 对象名= new 子类名称();或者:接口名称对象名= new实现类名称(); 父类： 12345678public class Fu &#123;public void method() &#123;System. out . print1n(\"父类方法\");&#125;public void methodFu() &#123;System . out . println(\"父类特有方法\");&#125;&#125; 子类： 12345public class Zi extends Fu &#123;@Overridepublic void method( )&#123;System. out . print1n(\"子类方法\");&#125; 123456789public class Demo01Multi &#123;public static void main(String[] args) &#123;//使用多态的写法/左侧父类的引用，指向了右侧子类的对象Fu obj = new Zi();obj.method(); //输出子类方法而不是父类方法obj.methodFu(); //输出父类特有方法 &#125;&#125; 多态中成员变量的使用特点访问成员变量的两种方式:1.直接通过对象名称访问成员变量:看等号左边是谁，优先用谁，没有则向上找。2.间接通过成员方法访问成员变量:看该方法属于谁，优先用谁，没有则向上找。 123456789public class Demo01MultiField &#123;public static void main(String[] args) &#123;//使用多态的写法，父类引用指向子类对象Fu obj = new Zi();System. out . println(obj.num); //父: 10//System. out. printin(obj.age); //错误写法! 因为父没有age这个变量System.out.print1n(\"===========\");obj. showNum(); //子类没有覆盖重写，就是父: 10&#125; //子类如果覆盖重写了，就是子 父类 123456package cn. itcast . day10. demo05;public class Fu &#123;int num = 10;public void showNum() &#123;System . out . print Mn(num);&#125; 子类： 12345678public class Zi extends Fu &#123;int num = 20;int age = 16;@Overridepublic void showNum() &#123;System. out . print1n(num) ; &#125;&#125; 多态中成员方法的使用特点 在多态的代码当中，成员方法的访问规则是:看new的是谁，就优先用谁，没有则向.上找。 口诀:编译看左边，运行看右边。 对比一下: 成员变量:编译看左边，运行还看左边。成员方法:编译看左边，运行看右边。 1234567public class Demo02Mult iMethod &#123;public static void main(String[] args) &#123;Fu obj = new Zi(); //多态obj . method(); //父子都有，优先用子obj . methodFu(); //子类没有，父类有，向上找到父类//编译看左边，左边是Fu, Fu当中没有methodZi方法， 所以编译报错。obj. methodZi(); //错误写法! 父类 1234567891011public class Fu /*extends object*/ &#123;int num = 10;public void showNum() &#123;System . out . println( num);&#125;public void method() &#123;System. out . print1n(\"父类方法\");&#125;public void methodFu() &#123;System . out . println(\"父类特有方法\");&#125; 子类 123456789101112131415public class Zi extends Fu &#123;int num = 20;int age = 16;@Overridepublic void showNum() &#123;System.out.print1n(num);&#125;@Overridepublic void method() &#123;System. out . println(\"子类方法\");&#125;public void methodZi() &#123;System. out . println(\"子类特有方法\");&#125;&#125; 使用多态的好处 向上转型 代码实现： 父类： 123public abstract class Animal &#123;public abstract void eat();&#125; 子类： 123456public class Cat extends Animal &#123;@Overridepublic void eat() &#123;System.out.print1n( \"猫吃鱼\");&#125;&#125; 主类： 123456public class Demo01Main &#123;public static void main(String[]args)&#123;//对象的向上转型，就是，父类引用指向之类对象。Animal animal = new Cat();animal.eat();&#125; 向下转型 对象一旦向上转型为父类，那么久无法调用子类原有特有的内容 对象的向下转型，其实是一个还原的动作代码实现：主类：1234567891011121314public class Demo01Main &#123;public static void main(String[] args) &#123;//对象的向上转型，就是:父类引用指向之类对象。Animal animal = new Cat(); //本来创建的时候是一只猫animal.eat(); //猫吃鱼//animal.catchMouse(); //错误写法!//向下转型，进行“还原”动作Cat cat = (Cat) animal;cat . catchMouse(); //猫抓老鼠//下面是错误的向下转型//本来new的时候是一只猫， 现在非要当做狗Dog dog = (Dog) animal;&#125;&#125; 子类狗类：123456789public class Dog extends Animal &#123;@Overridepublic void eat() &#123;System. out . println( \"狗吃SHIT\");&#125;public void watchHouse( ) &#123;System. out . print1n(\"狗看家\"); &#125;&#125; 子类猫类：123456public class Cat extends Animal &#123;@Overridepublic void eat() &#123;System.out.print1n( \"猫吃鱼\"); &#125;&#125; instanceof 关键字的使用 如何才能知道一个父类引用的对象，本来是什么子类?格式:对象instanceof 类名称这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例 1234567891011121314151617public class Demo02Instanceof &#123;public static void main(String[] args)&#123;Animal animal = new Cat(); //本来是一只猫animal.eat(); //猫吃鱼//如果希望调用子类特有方法，需要向下转型//判断一下父类引用animal本来是不是Dogif (animal instanceof Dog) &#123;Dog dog = (Dog) animal ;dog. watchHouse();&#125;//判断一下animal本来是不是Catif (animal instanceof Cat)&#123;Cat cat = (Cat) animal;cat. catchMouse();&#125;&#125;&#125; 与接口和多态相关的例题 案例要求 笔记本电脑(laptop) 通常具备使用USB设备的功能。 在生产时，笔记本都预留了可以插入USB设备的USB接口，但具体是什么USB设备，笔记本厂商并不关心，只要符合USB规格的设备都可以。 定义USB接口，具备最基本的开启功能和关闭功能。 鼠标和键盘要想能在电脑上使用,那么鼠标和键盘也必须遵守USB规范，实现USB接口，否则鼠标和键盘的生产出来也无法使用。 案例分析： 进行描述笔记本类，实现笔记本使用USB鼠标、USB键盘●USB接口，包含打开设备功能、关闭设备功能●笔记本类,包含开机功能、关机功能、使用USB设备功能●鼠标类，要实现USB接口，并具备点击的方法●键盘类，要实现USB接口，具备敲击的方法 电脑类： 12345678910111213141516171819public class Computer &#123;public void power0n() &#123;System . out . println( \"笔记本电脑开机\");&#125;public void power0ff() &#123;.System . out . print1n( \"笔记本电脑关机\");&#125;//使用USB设备的万法，使用接口作为万法的爹数public void useDevice(USB usb) &#123;usb.open(); //打开设备if (usb instanceof Mouse) &#123; // -定要先判断Mouse mouse = (Mouse) usb; //向下转型mouse.click(); &#125; else if (usb instanceof Keyboard) &#123; //先判断Keyboard keyboard = (Keyboard) usb; //向下转型keyboard . type();&#125;&#125; 鼠标类： 12345678910111213//鼠标就是一 -个USB设备public class Mouse implements USB &#123;@Overridepublic void open() &#123;System . out . println(“打开鼠标\");&#125;@Overridepublic void close() &#123;System. out .printin(\"关闭鼠标\");白public void click() &#123;System. out . printin( \"鼠标点击\");&#125; 键盘类： 123456789101112//键盘就是一-个USB设备public class Keyboard implements USB &#123;@Overridepublic void open() &#123;System . out . println(“打开键盘\");@Overridepublic void close() &#123;System. out . print1n(\"关闭键盘\");public void type() &#123;System. out . println(\"键盘输入\");&#125;&#125; usb接口： 1234public interface USB &#123;public abstract void open(); //打开设备public abstract void close(); //关闭设备&#125; 主类： 1234567891011121314151617181920c1ass Demiomlain&#123;blic static void main(String[] args) &#123;//首先创建一个笔记本电脑Computer computer = new Computer();computer. power0n( );//准备一个鼠标， 供电脑使用Mouse. mouse = new Mouse();//首先进行向上转型USB usbMouse = new Mouse(); //多态写法//参数是US8类型，我正好传递进去的就是usB鼠标computer.useDevice(usbMouse);//创建一个USB键盘Keyboard keyboard = new Keyboard(); //没有使用多态写法//方法参数是USB类型，传递进去的是实现类对象computer. useDevice(keyboard); //正确写法!也发生了向上转型//使用子类对象，匿名对象，也可以computer. useDevice(new Keyboard()); //也是正确写法computer . powerOff() ;&#125;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"eclipse使用小技巧（持续更新...）","slug":"使用技巧","date":"2020-03-29T05:48:01.554Z","updated":"2020-03-29T06:07:18.089Z","comments":true,"path":"2020/03/29/使用技巧/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"使用技巧快速完成for循环三部件（eclipse不适用） 假如要 i=0；i&lt;100;i++ 只需要 100.fi＋回车·","text":"使用技巧快速完成for循环三部件（eclipse不适用） 假如要 i=0；i&lt;100;i++ 只需要 100.fi＋回车·","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"数学工具Maths类","slug":"数学工具Maths类","date":"2020-03-29T05:48:01.554Z","updated":"2020-03-29T06:21:53.459Z","comments":true,"path":"2020/03/29/数学工具Maths类/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/%E6%95%B0%E5%AD%A6%E5%B7%A5%E5%85%B7Maths%E7%B1%BB/","excerpt":"数学工具Maths类 java. util.Math 类是数学相关的工具类,里面提供了大量的静态方法,完成与数学运算操作。 public static double abs(double num): 获取绝对值。有多种重载。 public static double ceil (double num):向上取整。 public static double floor(double num): 向下取整。 public static long round(double num):四舍五入。 12345678910111213141516171819public static void main(String[] args) &#123;//获取绝对值System . out . print1n(Math . abs(3.14)); // 3.14System. out . println(Math.abs(0)); //0System. out . print1n(Math.abs(-2.5)); // 2.5System . out . print1n(\"=============\");//向上取整System . out . print1n(Math.ceil(3.9)); // 4.0System . out . print1n(Math.ceil(3.1)); // 4.0System. out . println(Math.ceil(3.0)); // 3.0System. . out . print1n(\"=============\");//向下取整，抹零.System . out . print1n(Math.floor(30.1)); // 30.0System. . out . println(Math. floor(30.9)); // 30.0System . out . print1n(Math.floor(31.0)); // 31.0System . out . print1,(\"=============\");//四舍五入 (保留整数)System . out . println(Math. round(20.4)); // 20 System . out . println(Math. round(10.5)); // 11","text":"数学工具Maths类 java. util.Math 类是数学相关的工具类,里面提供了大量的静态方法,完成与数学运算操作。 public static double abs(double num): 获取绝对值。有多种重载。 public static double ceil (double num):向上取整。 public static double floor(double num): 向下取整。 public static long round(double num):四舍五入。 12345678910111213141516171819public static void main(String[] args) &#123;//获取绝对值System . out . print1n(Math . abs(3.14)); // 3.14System. out . println(Math.abs(0)); //0System. out . print1n(Math.abs(-2.5)); // 2.5System . out . print1n(\"=============\");//向上取整System . out . print1n(Math.ceil(3.9)); // 4.0System . out . print1n(Math.ceil(3.1)); // 4.0System. out . println(Math.ceil(3.0)); // 3.0System. . out . print1n(\"=============\");//向下取整，抹零.System . out . print1n(Math.floor(30.1)); // 30.0System. . out . println(Math. floor(30.9)); // 30.0System . out . print1n(Math.floor(31.0)); // 31.0System . out . print1,(\"=============\");//四舍五入 (保留整数)System . out . println(Math. round(20.4)); // 20 System . out . println(Math. round(10.5)); // 11 实例 题目:计算在-10.8到5.9之间，绝对值大于6或者小于2. 1的整数有多少个? ![image-20200325232317810](E:\\MyBlog\\source\\images\\Java notes_images\\image-20200325232317810.png) 作图分析： ![image-20200325232317810](E:\\MyBlog\\source\\images\\Java notes_images\\image-20200325232317810.png) 代码分析： 1.既然已经确定了范围，for循环2.起点位置-10. 8应该转换成为-10，两种办法:2.1可以使用Math.ceil方法， 向上(向正方向)取整2.2.强转成为int，自动舍弃所有小数位3.每一个数字都是整数，所以步进表达式应该是num++，这样每次都是+1的。4.如何拿到绝对值: Math. abs方法。5.一旦发现了一个数字， 需要让计数器+ +进行统计。 12345678910111213141516public class Demo04MathPractise &#123;public static void main(String[] args) &#123;int count = 0; //符合要求的数量double min = -10.8;double max = 5.9;//这样处理，变量就是区间之内所有的整数for(inti=(int)min;i&lt;max;i++)&#123;int abs = Math.abs(i); //绝对值if(abs》6||abs&lt;2.1)&#123;System. out. print1n(i);count++; &#125;&#125;System.out.println(\"总共有:”+ count); // 9 &#125;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"接口","slug":"接口","date":"2020-03-29T05:48:01.544Z","updated":"2020-03-29T06:07:38.964Z","comments":true,"path":"2020/03/29/接口/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/%E6%8E%A5%E5%8F%A3/","excerpt":"接口 接口就是多个类的公共规范。接口是一种引用数据类型，最重要的内容就是其中的 抽象方法。备注:换成了关键宇interface之后，编译生成的字节码文件仍然是: .java –&gt; .class。 . 如何定义一个接口的格式: 123public interface 接口名称&#123; //接口内容&#125; 如果是Java 7，那么接口中可以包含的内容有:1.常量2.抽象方法 如果是Java 8,还可以额外包含有:3.默认方法4.静态方法 如果是Java 9, 还可以额外包含有:5.私有方法","text":"接口 接口就是多个类的公共规范。接口是一种引用数据类型，最重要的内容就是其中的 抽象方法。备注:换成了关键宇interface之后，编译生成的字节码文件仍然是: .java –&gt; .class。 . 如何定义一个接口的格式: 123public interface 接口名称&#123; //接口内容&#125; 如果是Java 7，那么接口中可以包含的内容有:1.常量2.抽象方法 如果是Java 8,还可以额外包含有:3.默认方法4.静态方法 如果是Java 9, 还可以额外包含有:5.私有方法 接口的抽象方法定义 在任何版本的Java中，接口都能定义抽象方法。 12345678910public interface MyInterfaceAbstract &#123;//这是一个抽象方法public abstract void methodAbs1();//这也是抽象方法abstract void methodAbs2();//这也是抽象方法public void methodAbs3();//这也是抽象方法void methodAbs4();&#125; 注意事项: 接口当中的抽象方法，修饰符必须是两个固定的关键字: public abstract 这两个关键字修饰符，可以选择性地省略。 (今天刚学，所以不推荐。) 方法的三要素，可以随意定义。 接口的抽象方法的使用步骤： 接口不能直接使用， 必须有一个”实现类”来实现接口(和抽象的要求类似) 格式： 123public class 实现类名称 implement 接口名称&#123;//&#125; 接口的实现类必须覆盖重写(实现)接口中所有的抽象方法。(和抽象的要求类似) 实现:去掉abstract关键字，加上方法体大括号。 123456789101112131415161718 public class MyInterfaceAbstractImpl implements MyInterfaceAbstract &#123;@Overridepublic void methodAbs1() &#123;System. out . println(\"这是第-一个方法! \");&#125;@Overridepublic void methodAbs2(). &#123;.System. out . println(\"这是第二个方法! \");&#125;@Overridepublic void methodAbs3() &#123;System. out . println(\"这是第三个方法! \");&#125;@Overridepublic void methodAbs4() &#123;System . out . println(\"这是第四个方法!1\");&#125;&#125; 创建实现类的对象，进行使用。 12345678910public class Demo01Interface &#123;public static void main(String[] args) &#123;//错误写法!不能直接new接口对象使用。//MyInterfaceAbstract inter = new MyInterfaceAbstract();//创建实现类的对象使用MyInterfaceAbstractImpl impl = new MyInterfaceAbstractImpl();impl . methodAbs1();impl . methodAbs2( );&#125;&#125; 注意事项： 如果实现类并没有覆盖重写接口的所有抽象方法，那么这个实现类自己就必须是抽象类 接口的默认方法 格式:public default 返回值类型方法名称(参数列表) {方法体 } 备注，接口当中的默认方法，可以解决接口升级的问题。 举例： 12345public interface MyInterfaceDefault &#123;//抽象方法public abstract void methodAbs();//新添加了一个抽象方法public abstract void methodAbs2(); 但是当你新添加了一个抽象方法时，你的实现类由于只是重写了一个之前的抽象方法1… MyInterfaceDefaultA类： 12345public class MyInterfaceDefaultA implements MyhterfaceDefault &#123;@Overridepublic void methodAbs() &#123;System. out . println(\"实现了抽象方法，AAA\");&#125; 这样程序就会报错，出现问题，因此我们需要有默认方法来解决接口升级的问题，只需要将新增加的方法改成默认方法就可以 改： 123456789public interface MyInterfaceDefault &#123;//抽象方法public abstract void methodAbs();//新添加了一个抽象方法//public abstract void methodAbs2();//新添加一个默认方法public default void methodDefault()&#123; System.out.println(\"这是一个默认方法\")&#125; 主类调用一下 12345678public class Demo02Interface &#123;public static void main(String[] args) &#123;//创建了实现类对象MyInterfaceDefaultA a = new MyInterfaceDefaultA();a. methodAbs(); //调用抽象方法，没有问题，实际运行的是右侧实现类(见MyInterfaceDefaultA类那里)。a. methodDefault();//默认方法，虽然MyInterfaceDefaultA没有重写这个，但是这是默认方法，不需要，也可以调用 &#125;&#125; 如何实现类也覆盖重写了默认方法，那也会被修改的 接口的静态方法 从Java 8开始，接口当中允许定义静态方法。提示:就是将abstract或者 defaul t换成static即可，带上方法体。 接口静态方法的使用格式 格式:public static 返回值类型方法名称(参数列表) {方法体 接口类： 1234public interface MyInterfaceStatic &#123;public static void methodStatic()&#123;System. out . print1n( \"这是接口的静态方法! \");&#125; 实现类： 12public class MyInterfaceStaticImpl implements MyInterfaceStatic &#123;&#125; 主类： 12345678910public class Demo03Interface &#123;public static void main(String[] args) &#123; //创建了实现类对象MyInterfaceStaticImpl impl = new MyInterfaceStaticImp1();//错误写法!//impl.methodStatic();//直接通过接口名称调用静态方法MyInterfaceStatic . methodStatic(); &#125;&#125; 注意事项:不能通过接口实现类的对象来调用接口当中的静态方法。 正确用法:通过接口名称，直接调用其中的静态方法。格式:接口名称.静态方法名(参数); 接口的私有方法 接口私有方法的定义","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"继承","slug":"继承","date":"2020-03-29T05:48:01.544Z","updated":"2020-03-29T06:08:03.757Z","comments":true,"path":"2020/03/29/继承/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/%E7%BB%A7%E6%89%BF/","excerpt":"继承 面向对象的三大特性： 继承性 （继承是多态的前提） 封装性 多态性 继承的格式 在继承的关系中，子类就是一一个父类”。也就是说，子类可以被当做父类看待。例如父类是员工，子类是讲师，那么“讲师就是一一个员工”。 关系: is-a。 定义父类的格式: (一 个普通的类定义)public class 父类名称{}定义子类的格式:public class 子类名称extends 父类名称{//}","text":"继承 面向对象的三大特性： 继承性 （继承是多态的前提） 封装性 多态性 继承的格式 在继承的关系中，子类就是一一个父类”。也就是说，子类可以被当做父类看待。例如父类是员工，子类是讲师，那么“讲师就是一一个员工”。 关系: is-a。 定义父类的格式: (一 个普通的类定义)public class 父类名称{}定义子类的格式:public class 子类名称extends 父类名称{//} 1234//定义一个父类:员工public class Employee &#123;public void method( ) &#123;System. out . print1n( \"方法执行! \"); 123//定义了一个员工的子类:讲师public class Teacher extends Employee &#123;&#125; 12// 定义了员工的另一个子类:助教public class Assistant extends Employee &#123; 12345678910public class Demo01Extends &#123;public static void main(String[] args) &#123;. //创建了一个子类对象Teacher teacher = new Teacher( );// Teacher类当 中虽然什么都没写，但是会继承来自父类的method方法。teacher. method() ;//创建另一个子类助教的对象Assistant assistant = new Assistant(); assistant . method();| &#125; 继承的成员变量（方法）访问特点 直接通过子类对象访问成员变量。等号左边是谁， 就优先用谁，没有则向上找。间接通过成员方法访问成员变量:该方法属于谁，就优先用谁，没有则向.上找。 父类 12345678public class Fu &#123;int numFu = 10;int num = 100;public void methodFu() &#123;//使用的是本类当中的，不会向下找子类的System. out . print1n(num); &#125;&#125; 子类 12345678public class Zi extends Fu &#123;int numZi = 20;int num = 200;public void methodZi() &#123;//因为本类当中有num,所以这里用的是本类的num .System. out . print1n(num); &#125;&#125; 1234567891011121314151617181920public class Demo01ExtendsField &#123;public static void main(String[] args) &#123;Fu fu = new Fu(); //创建父类对象System. out . printin(fu. numFu); //只能使用父类的东西，没有任何子类内容System. out . print1n(\"=========\");Zi zi = new Zi();System. out . println(zi.numFu); // 10System. out . print1n(zi. numZi); // 20System. out . print1n(\"==========\");//等号左边是谁，就优先用谁System. out . println(zi.num); //优先子类，200//System. out. printin(zi.abc); //到处都没有，编译报错!System. out.print1n(=\"=========\");1/这个方法是子类的，优先用子类的，没有再向上找zi . methodZi(); // 200//这个方法是在父类当中定义的zi . methodFu(); // 100&#125;&#125; 父类的成员变量和子类的成员变量和子类的局部变量重名怎么办 局部变量: 直接写成员变量名本类的成员变量: this.成员变量名父类的成员变量: super成员变量名 代码如下： 父类 123public class Fu &#123;int num = 10;&#125; 子类 123456789public class Zi extends Fu &#123;int num = 20;public void method() &#123;int num = 30;System. out . println(num); // 30,局部变量System. out . print1n(this.num); // 20,本类的成员变量System. out . print1n(super.num); // 10，父类的成员变量 &#125;&#125; 这样在主方法中执行zi.method()就会显示出30、20、10三种不同的变量值 继承中方法的覆盖重写 重写. (Override)概念: 在继承关系当中，方法的名称一样，参数列表也一样。 重写和重载的区别： 重写 (Override) :方法的名称一样， 参数列表[也一样]。覆盖、覆写。 重载(overload) :方法的名称一样，参数列表不一样。 方法的覆盖重写特点: 创建的是子类对象，则优先用子类方法。 方法覆盖重写的注意事项: 1.必须保证父子类之间方法的名称相同，参数列表也相同。@Override:写在方法前面，用来检测是不是有效的正确覆盖重写。这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。 2.子类方法的返回值必须小于等于父类方法的返回值范围。小扩展提示: java. lang. object类是所有类的公共最高父类(祖宗类)， ​ java. lang. String就是object的子类。 3.子类方法的权限必须大于等于父类方法的权限修饰符。小扩展提示: public &gt; protected &gt; (default) &gt; private备注: (default)不是关键字default， 而是什么都不写，留空。 什么时候需要用上方法的覆盖重写呢？ 代码演示： 1234567891011//本来的老款手机public class Phone &#123;public void call() &#123;System. out . println(\"打电话\");&#125;public void send() &#123; ISystem . out . println(\"发短信\");&#125;public void show() &#123;System. out . println(\"显示号码\");&#125; 12345678// 定义一个新手机，使用老手机作为父类public class NewPhone extends Phone &#123;@Overridepublic void show() &#123;super. show(); //把父类的show方法拿过来重复利用//自己子类再来添加更多内容System.out.print1n(\"显示姓名\");System.out.println(\"显示头像\"); 继承关系中，父子类构造方法的访问特点: 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。 子类构造可以通过super关键字来调用父类重载构造。 super的父类构造调用， 必须是子类构造方法的第一 个语句。不能一 个子类构造调用多次super构造。 总结: 子类必须调用父类构造方法，不写则赠送super(); 写了则用写的指定的super调用，super只能有一个， 还必须是第一 个。 代码演示 父类： 123456public class Fu &#123;public Fu() &#123;System. out . println(\"父类无参构造\"); .public Fu(int num) &#123;System. out . println(\"父类有参构造! \");&#125; 子类: 123456789101112public class Zi extends Fu &#123;public Zi() &#123;super(); //在调用父类无参构造方法//super( num: 20); //在调用父类重载的构造方法System. out print1n(\"子类构造方法! \");&#125; public void method() &#123;//super(); //错误写法!只有子类构造方法，才能调用父类构造方法。 &#125;&#125; 继承的三个特征 Java语言是单继承的。 一个类的直接父类只能有唯一一个 1234class A &#123;&#125;class B extends A&#123;&#125; //正确class C &#123;&#125;class D extendsA, C&#123;&#125; //错误 Java语言可以多级继承 我有一个父亲，我的父亲还有一个父亲，也就是爷爷 java.lang.Object就是祖爷爷，最头头 123class A &#123;&#125;class B extends A&#123;&#125; class C extends B&#123;&#125; 一个子类的直接父类是唯一的 但是一个父类可以拥有很多子类（可以有很多兄弟姐妹） 123class A&#123;&#125;class B extends A&#123;&#125;class C extends A&#123;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"构造方法","slug":"构造方法","date":"2020-03-29T05:48:01.534Z","updated":"2020-03-29T06:09:27.737Z","comments":true,"path":"2020/03/29/构造方法/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95/","excerpt":"构造方法什么是构造方法？构造方法是专门用来创建对象的方法，当我们通过关键字new创建新的对象的时候，其实就是使用构造方法。 构造方法的格式： public 类名称（参数类型 参数名称）{ 方法体} 注意事项: 构造方法的名称必须和类名称完全一样，大小写也要一样 构造方法不要写返回值，连void都不要写！ 构造方法不能return一个返回值 如果没有编写任何构造方法，那么编译器将会自动构造一个，没有参数没有方法体，什么都没有。 如果一旦编写了至少一个构造方法，那么编译器将不会在自动构造 构造方法也可以重载","text":"构造方法什么是构造方法？构造方法是专门用来创建对象的方法，当我们通过关键字new创建新的对象的时候，其实就是使用构造方法。 构造方法的格式： public 类名称（参数类型 参数名称）{ 方法体} 注意事项: 构造方法的名称必须和类名称完全一样，大小写也要一样 构造方法不要写返回值，连void都不要写！ 构造方法不能return一个返回值 如果没有编写任何构造方法，那么编译器将会自动构造一个，没有参数没有方法体，什么都没有。 如果一旦编写了至少一个构造方法，那么编译器将不会在自动构造 构造方法也可以重载 例如： 123456789101112131415// 这是我写的一个有参数的构造方法(全参构造方法)public class Student&#123;public Student(String name ,int age)&#123; this.name = name; this.age = age;&#125; //这是我写的第二个构造方法(无参构造方法) public Student()&#123; &#125; //只要我写了第一个构造方法，那么默认的最简单的构造方法将不会自动生成了//两个构造方法一个有参数，一个无参数，不印象，因为构造方法也可以重载 123456public class Student&#123; public Student&#123; system.out.println(\"构造方法执行啦！\") //这就是一个构造方法 &#125;&#125; 构造方法的用途其实就是创建对象罢了 Student stu = new Studnet(); 当我们在写这个的时候，其实就是一个构造方法。 一个完整的例子理解构造方法的作用一个完整的类，其实应该如此： 所有的成员变量都要使用private关键字来进行修饰 每一对成员变量都有一对Getter、Setter方法 编写一个无参的构造方法 编写一个有参的构造方法 这样的一个标准的类就叫做一个 Java Bean 12345678910111213141516171819202122232425262728293031public class Student&#123; //成员变量 private String name; private int age; //无参构造方法 public Student()&#123; //方法名和类名一致，都是Student吧 Systent.out.println(\"无参构造方法执行啦！\"); &#125; //有参构造方法 public Student(String name,int age)&#123; System.out.println(\"全参构造方法执行啦！\"); this.name = name; this.age = age; // 就是将默认的name和age 传递给最上头的成员变量 &#125; //还要有getter setter方法 public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125;&#125; 分别有什么用？ 全参构造方法，就是给我们在构造一个新的学生对象的时候，可以直接的给他设置参数，设置这个学生的年龄啊名字。 那么getter 和setter 的方法就是没用的了吗？ 并不，getter和 setter方法 是用来我们后续对这个学生进行属性的修改 所以有参数的构造方法的作用正是：方便我们在创建对象的时候数据的初始化，尤其是不变的数据，比如我们的名字，省去复杂的get 和set","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"抽象","slug":"抽象","date":"2020-03-29T05:48:01.534Z","updated":"2020-03-29T06:09:50.434Z","comments":true,"path":"2020/03/29/抽象/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/%E6%8A%BD%E8%B1%A1/","excerpt":"抽象 如果父类方法中的方法不确定，如何进行{}方法体实现，那么这样的方法就是抽象方法 抽象方法和抽象类的格式 抽象方法: 就是加上abstract关键字，然后去掉大括号，直接分号结束。抽象类: 抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。 如何使用抽象类和抽象方法: 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。 覆盖重写(实现):子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使 用","text":"抽象 如果父类方法中的方法不确定，如何进行{}方法体实现，那么这样的方法就是抽象方法 抽象方法和抽象类的格式 抽象方法: 就是加上abstract关键字，然后去掉大括号，直接分号结束。抽象类: 抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。 如何使用抽象类和抽象方法: 不能直接创建new抽象类对象。 必须用一个子类来继承抽象父类。 子类必须覆盖重写抽象父类当中所有的抽象方法。 覆盖重写(实现):子类去掉抽象方法的abstract关键字，然后补上方法体大括号。 创建子类对象进行使 用 抽象类animal： 1234567public abstract class Animal &#123; //这是一个抽象方法，代表吃东西，但是具体吃什么(大括号的内容)不确定。 public abstract void eat(); //这是普通的成员方法 public void normalMethod() &#123; &#125;&#125; 123456public class Cat extends Animal &#123; @Overridepublic void eat() &#123;System. out . print1n( \"猫吃鱼\"); // 点2和点3 &#125;&#125; 123456public class DemoMain &#123;public static void main(String[] args) &#123;//Animal animal = new Animal(); //错误写法!不能直接创建抽象类对象 点1Cat cat = new Cat(); // 点4cat.eat();&#125; 抽象方法和抽象类的注意事项 关于抽象类的使用，以下为语法上要注意的细节，虽然条目较多,但若理解了抽象的本质,无需死记硬背。 抽象类不能创建对象，如果创建，编译无法通过而报错。只能创建其非抽象子类的对象。理解: 假设创建了抽象类的对象，调用抽象的方法，而抽象方法没有具体的方法体，没有意义。 抽象类中,可以有构造方法，是供子类创建对象时，初始化父类成员使用的。理解: 子类的构造方法中，有默认的super()， 需要访问父类构造方法。 抽象父类： 123456public abstract class Fu &#123;public Fu()&#123; System.out.println(“抽象父类构造方法执行! \"); &#125;public abstract void eat();&#125; 子类： 12345678910public class Zi extends Fu &#123;public Zi() &#123;// super(); 编译器赠送给你的super(),因此有父类的抽象方法执行&#125;System.out.println(\"子类构造方法执行\"); @Overridepublic void eat() &#123;System . out . println( \"吃饭饭\");&#125; 主类执行： 12345public class DemoMain &#123;public static void main(String[] args)&#123;Zi zi = new Zi();zi.eat();&#125; 执行结果： 抽象父类构造方法执行!子类构造方法执行吃饭饭 先执行父类的构造方法，再执行子类的。 抽象类中，不一定包含抽象方法，但是有抽象方法的类必定是抽象类。理解:未包含抽象方法的抽象类，目的就是不想让调用者创建该类对象，通常用于某些特殊的类结构设计。 1234一个抽象类不一定含有抽象方法，只要保证抽象方法所在的类是抽象类，即可。这样没有抽象方法的抽象类，也不能直接创建对象，在一些特殊场景 下有用途。public abstract c1ass MyAbstract &#123; 抽象类的子类，必须重写抽象父类中所有的抽象方法，否则，编译无法通过而报错。除非该子类也是抽象类。理解:假设不重写所有抽象方法，则类中可能包含抽象方法。那么创建对象后，调用抽象的方法，没有意义。 1234//最高的抽象父类public abstract class Animal &#123;public abstract void eat();pub1ic abstract void sleep(); // 有两个抽象方法！！ 如果没有完全重写抽象父类中所有的抽象方法，该子类只能也是抽象类 12345678//子类也是一个抽象类(abstract)public abstract class Dog extends Animal &#123;@Overridepublic void eat() &#123;System . out . println( \"狗吃骨头\");&#125;// public abstract void sleep();&#125; 当然他的孙子辈的类可以重写之前的抽象方法 12345public class DogGolden extends Dog &#123;@Overridepublic void sleep() &#123;System. out . print1n( \"呼呼..\");&#125; 执行主类 123456789public class DemoMain &#123;public static void main(String[] args) &#123;//Animal animal = new Animal(); //错误!//Dog dog=new Dog(); //错误，这也是抽象类Dog2Ha ha = new Dog2Ha(); //这是普通类，可以直接new对象。ha.eat();ha.sleep(); &#125;&#125; 执行结果： 狗吃骨头 呼呼. . 发红包实例运用抽象类 导图分析： 代码分析： 父类用户类： 1234567891011121314151617181920212223242526public class User&#123;private String name; //姓名private int money; //余额，也就是当前用户拥有的钱数 public User() &#123;&#125;public User(String name, int money) &#123;this.name = name;this .money = money;&#125;//展示一下当前用户有多少钱public void show() &#123;System . out . println(\"我叫:”+ name + \",我有多少钱:”+ money);public String getName() &#123;return name ;&#125;public void setName(String name) &#123;this.name = name;&#125;pub1ic int getMoney() &#123;return money;&#125;public void setMoney(String money) &#123;this.money = money; &#125;&#125; 子类群主类 1234567891011121314151617181920212223242526272829303132import java. util.ArrayList;public c1ass Manager extends User &#123;public Manager() &#123;&#125;public Manager(String name, int money) &#123;super(name, money);&#125;public ArrayList&lt;Integer&gt; send(int totalMoney, int count) &#123;//首先需要一个集合，用来存储若干个红包的金额ArrayList&lt;Integer&gt; redList = new Arraylist&lt;&gt;();//首先看- -下群主自己有多少钱int leftMoney = super.getMoney(); //群主当前余额if (totalMoney &gt; leftMoney) &#123;System.out.println(\"余额不足\");return redList; //返回空集合&#125;//扣钱，其实就是重新设置余额super.setMoney(1eftMoney - totalMoney);//发红包需要平均拆分成为count份int avg = totalMoney / count ;int mod = totalMoney % count; //余数，也就是甩下的零头//除不开的零头，包在最后一个红包当中//下面把红包一个一个放到集合当中for(inti=0;i&lt;count-1;i++)&#123;redList.add(avg);&#125;//最后一个红包intlast=avg+mod;redList.add(last);return redList;&#125;&#125; 子类群员类 123456789101112131415161718192021import java.util.Arraylist;import java.util.Random;//昔通成员public class Member extends User &#123;public Member() &#123;&#125;public Member(String name, int money) &#123;super(name, money);&#125;public void receive(ArrayList&lt;Integer&gt; list) &#123;//从多个红包当中随便抽取一个，给我自己。//随机获取一个集合当中的索引编号int index = new Random() . nextInt(list.size());//根据索引，从集合当中删除，并且得到被删除的红包，给我自己int delta = list. remove(index);//当前成员自己本来有多少钱:int money = super . getMoney();//加法，并且重新设置回去super. setMoney(money + delta);&#125;&#125; 主类 12345678910111213141516171819202122232425import java.util.ArrayList;public class MainRedPacket &#123;public static void main(String[] args) &#123;Manager manager = new Manager( name: \"群主\"，money: 100);Member one = new Member( name:\"成员A\"，money: 0);Member two = new Member( name: \"成员B\"，money: 0);Member three = new Member( name: \"成员C\" , money: 0);manager . show(); // 100one. show(); //0two. show(); //0three. show(); //0System . out . print1n(\"=============\");//群主总共发20块钱，分成3个红包ArrayList&lt;Integer&gt; redList = manager. send( totalMoney: 20，count: 3) ;//三个普通成员收红包one . receive(redList);two. receive(redList);three . receive(redList);manager . show(); // 100- 20=80//6、6、8,随机one. . show(); two. show( );three. show() ;&#125;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"super关键字和this关键字","slug":"super关键字","date":"2020-03-29T05:48:01.524Z","updated":"2020-03-29T06:10:10.818Z","comments":true,"path":"2020/03/29/super关键字/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/super%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"super关键字和this关键字super super关键字的三种用法 在子类的成员方法中，访问父类的成员变量。 在子类的成员方法中，访问父类的成员方法。 在子类的构造方法中，访问父类的构造方法。 123456public class Fu &#123;int num = 10;public void method() &#123;System . out . println(\"父类方法\"); &#125;&#125;","text":"super关键字和this关键字super super关键字的三种用法 在子类的成员方法中，访问父类的成员变量。 在子类的成员方法中，访问父类的成员方法。 在子类的构造方法中，访问父类的构造方法。 123456public class Fu &#123;int num = 10;public void method() &#123;System . out . println(\"父类方法\"); &#125;&#125; 12345678910111213public class Zi extends Fu &#123;int num = 20;public Zi() &#123;super();&#125;public void methodZi() &#123;System. out . print1n(super. num); //父类中的num &#125;public void method() &#123;super . method(); //访问父类中的methodSystem. out . print1n(\"子类方法\"); &#125;&#125; this super关键字用来访问父类内容， 而this关键字用来访问本类内容。用法也有3三种: 在本类的成员方法中，访问本类的成员变量。 在本类的成员方法中，访问本类的另一个成员方法。 在本类的构造方法中，访问本类的另一个构造方法。 在第三种用法当中要注意: this(... )调用也必须是构造方法的第一 个语句，唯一一个。 super和this两种构造调用，不能同时使用。 (因为他们都必须放在第一排只能唯一) 1234567891011121314151617181920212223242526public class Zi extends Fu &#123;int num = 20;public Zi() &#123;//super(); //这一行不再赠送 （注意的第二点）this( n: 123); //本类的无参构造，调用本类的有参构造this(1，2); //错误写法! （注意的第一点）&#125;public Zi(int n) &#123;this( n: 1，m: 2);&#125;public Zi(int n, int m) &#123;&#125; public void showNum() &#123;int num = 10;System.out.print1n(num); //局部变量System.out. println(this.num); //本类中的成员变量 （用法1）System.out.println(super.num); //父类中的成员变量 public void methodA() &#123;System. out. println(\"AAA\");public void methodB() &#123;this .methodA(); //（用法2）System. out . println(\"BBB\"); &#125;&#125; super 和 this 的内存图解","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"static关键字","slug":"static关键字","date":"2020-03-29T05:48:01.524Z","updated":"2020-03-29T06:10:54.063Z","comments":true,"path":"2020/03/29/static关键字/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/static%E5%85%B3%E9%94%AE%E5%AD%97/","excerpt":"static关键字 情景导入 – 什么情况下需要用static？ 如果一个参数使用了static关键字，那么这个属性将不再属于自己，而是属于所在的类的，多个对象共享同一份数据。 静态关键字修饰成员变量1234567891011121314151617181920212223242526public class Student &#123;private String name; //姓名pirivate int age; //年龄static String room; //所在教室 public Student() &#123;&#125;public Student(String name, int age) &#123;this.name = name;this.age = age;&#125;pub1ic String getName() &#123;return name ;&#125; pub1ic void setName(String name) &#123;this. name = name ;&#125; public int getAge()&#123;return age;&#125; pub1ic void getName(int age) &#123;this.age = age ;&#125;","text":"static关键字 情景导入 – 什么情况下需要用static？ 如果一个参数使用了static关键字，那么这个属性将不再属于自己，而是属于所在的类的，多个对象共享同一份数据。 静态关键字修饰成员变量1234567891011121314151617181920212223242526public class Student &#123;private String name; //姓名pirivate int age; //年龄static String room; //所在教室 public Student() &#123;&#125;public Student(String name, int age) &#123;this.name = name;this.age = age;&#125;pub1ic String getName() &#123;return name ;&#125; pub1ic void setName(String name) &#123;this. name = name ;&#125; public int getAge()&#123;return age;&#125; pub1ic void getName(int age) &#123;this.age = age ;&#125; 123456789public class Demo &#123;public static void main(String[] args) &#123;Student one = new Student( name: \"郭靖\"，age: 19); one.room = \"101教室\" ;System . out . print1n(\"姓名:”+ one. getName() + \",年龄:”+ one.getAge() + \",教室: \" + one.room);Student two = new Student( name: \"黄蓉\"，age: 16);System. out . print1n(\"姓名:”+ two.getName() + \"。年龄:”+ two.getAge() + \",教室: \"+two.room); //虽然我没有赋值two的room，但是由于room是static关键字修饰的，那么它和one的是相同的&#125; 用静态关键字修饰成员方法 一旦使用static修饰成员方法，那么就成为了静态方法。静态方法不属于对象，而属于类 1234567891011121314151617181920public class MyClass &#123;int num; //成员变量static int numStatic; //静态变量//成员方法public void method() &#123;System. out . println(\"这是一个成员方法。 \");//成员方法可以访问成员变量System . out . println(num);//成员方法可以访问静态变量System . out . println(numStatic);&#125;//静态方法public static void methodStatic()&#123;System. out . println(\"这是一个静态方法。\");//静态方法可以访问静态变量System . out . println(numStatic);//静态不能直接访问非静态[重点]System. out. println(num); //错误写法!会报错 &#125;&#125; 12345678910111213141516171819public class Demo &#123;public static void main(String[] args) &#123;MyClass obj = new MyClass(); //首先创建对象//然后才能使用没有static关键字的内容obj.method();//1.对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。obj.methodStatic(); //正确，不推荐，这种写法在编译之后也会被javac翻译成为“类名称.静态方法名”MyClass.methodStatic(); //正确，推荐 //2.对于本类当中的静态方法，可以省略类名称myMethod(); Demo02StaticMethod.myMethod(); //完全等效&#125; public static void myMethod() &#123;System. out . println(\"自己的方法! \");&#125;&#125; 静态变量:类名称.静态变量静态方法:类名称.静态方法() 注意事项: 静态不能直接访问非静态。原因:因为在内存当中是先有的静态内容,后有的非静态内容。先人不知道后人，但是后人知道先人。 对于静态方法来说，可以通过对象名进行调用，也可以直接通过类名称来调用。 对于本类当中的静态方法，可以省略类名称 static静态的内存图 静态代码块 public class 类名称{static {//静态代码块的内容 }}特点:第一次用到本类时，静态代码块执行唯一的一次。静态内容总是优先于非静态，所以静态代码块比构造方法先执行。 静态代码块的典型用途:用来一次性地对静态成员变量进行赋值。 123456public class Demo04Static &#123;public static void main(String[] args) &#123;Person one = new Person();Person two = new Person(); &#125;&#125; 1234567public class Person &#123;static &#123;System . out . println(“静态代码块执行! \"); &#125;public Person() &#123;System . out . println(\"构造方法执行!\");&#125; 输出结果： 静态代码块执行! //静态的优于非静态，所以在前 而且只会用一次 构造方法执行! //对应one的 构造方法执行! //对应two的","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"Scanner 扫描器","slug":"Scanner","date":"2020-03-29T05:48:01.514Z","updated":"2020-03-29T06:11:36.869Z","comments":true,"path":"2020/03/29/Scanner/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/Scanner/","excerpt":"ScannerScanner的使用步骤​ 1.导包 import java.util.Scanner; ​ 2.创建 Scanner sc = new Scanner(System.in); ​ 3.使用 (使用之前最好需要先来一个syso输出提示) int a =sc.nextInt( );","text":"ScannerScanner的使用步骤​ 1.导包 import java.util.Scanner; ​ 2.创建 Scanner sc = new Scanner(System.in); ​ 3.使用 (使用之前最好需要先来一个syso输出提示) int a =sc.nextInt( );","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"random的使用","slug":"random的使用","date":"2020-03-29T05:48:01.514Z","updated":"2020-03-29T06:12:00.799Z","comments":true,"path":"2020/03/29/random的使用/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/random%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"random的使用 random类用来生成随机数字 使用起来也是三个步骤： 1.导包 import java.util.Random; ​ 2.创建 Random r = new Random( ); ​ 3.使用 例如：获取一个随机的int数字(这样获取的数字是所有int范围的，包括正负) ​ int num = r.nextInt（）； ​ 获取生成指定范围的数字的随机数(左闭右开原则 ) ​ int num = r.nextInt(3); //此时的3 代表[0,3) 0~2的意思","text":"random的使用 random类用来生成随机数字 使用起来也是三个步骤： 1.导包 import java.util.Random; ​ 2.创建 Random r = new Random( ); ​ 3.使用 例如：获取一个随机的int数字(这样获取的数字是所有int范围的，包括正负) ​ int num = r.nextInt（）； ​ 获取生成指定范围的数字的随机数(左闭右开原则 ) ​ int num = r.nextInt(3); //此时的3 代表[0,3) 0~2的意思 思考： 如果题目要求是从1到3，而不是从0开始那怎么办呢？ 我们可以通过加1的操作，实现，代码如下： 12345public static void main(String[] args)&#123; Random r =new Random(); int result = (r.nextInt(3)+1); //这样我们可以将通过用result ，ressult再加1就行了&#125; 用random模块设计猜游戏数字 1234567891011121314151617181920212223242526import java.util.Scanner;import java.util.Random;public class compareNum &#123; public static void main(String[] args) &#123; Random r = new Random(); int answer = r.nextInt(100); tip: while (true) &#123; System.out.println(\"请输入你猜的数字：\"); Scanner sc = new Scanner(System.in); int a =sc.nextInt(); if (answer == a) &#123; System.out.println(\"恭喜你，猜对了！\"); break; &#125; else if(a&gt;answer) &#123; System.out.println(\"猜大了,再猜一次吧\"); continue tip; &#125; else if(a&lt;answer) &#123; System.out.println(\"猜小了，再猜一次吧\"); continue tip; &#125; &#125; &#125;&#125; 总结 巧用标签实现循环的跳转 break和continue的区别使用： break是跳过整个循环 ··continue是跳过当次循环","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"java中还有匿名对象？！！","slug":"java中还有匿名对象","date":"2020-03-29T05:48:01.504Z","updated":"2020-03-29T06:12:39.423Z","comments":true,"path":"2020/03/29/java中还有匿名对象/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/java%E4%B8%AD%E8%BF%98%E6%9C%89%E5%8C%BF%E5%90%8D%E5%AF%B9%E8%B1%A1/","excerpt":"java中还有匿名对象？！！12345678910111213//先用标准格式创建对象public class DemoName&#123; public static void main(String[]args)&#123; Person pe = new Person(); pe.name = \"科比\" pe.showName(); System.out.println(\"==========\") &#125;&#125;//匿名对象用法new Person().name = \"Curry\";new Person().showName();","text":"java中还有匿名对象？！！12345678910111213//先用标准格式创建对象public class DemoName&#123; public static void main(String[]args)&#123; Person pe = new Person(); pe.name = \"科比\" pe.showName(); System.out.println(\"==========\") &#125;&#125;//匿名对象用法new Person().name = \"Curry\";new Person().showName(); 可以看到虽然用匿名对象没有new一个pe，但是也是一样可以修改name属性 但是直接showName（），并不可以show出Curry 匿名对象只能使用一次，下次再用不得不再创建一个新的对象 什么时候才用匿名对象？ 匿名对象只是一个简略的用法，当确定一个对象只使用唯一的一次，就可以使用匿名对象。 实例 1234567891011121314151617181920212223242526 public static void main(String[] args) &#123; //一般方式 Scanner sc = new Scanner(System.in); int num =sc.nextInt(); //匿名对象的方式 int num = new Scanner(System.in).nextInt(); //使用一般方法传入参数 Scanner sc = new Scanner(System.in); methodParam(sc); //使用匿名对象传参 methodParam(new Scanner(System.in)); public static void methodParam(Scanner sc) &#123; int num = sc.nextInt(); System.out.println(\"输出的是\"+num); &#125; //一般返回值 public static Scanner methodReturn() &#123; Scanner sc = new Scanner(System.in); return sc; //使用匿名对象传参 return new Scanner(System.in); &#125;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"private关键字的使用","slug":"private关键字的使用","date":"2020-03-29T05:48:01.504Z","updated":"2020-03-29T06:12:18.065Z","comments":true,"path":"2020/03/29/private关键字的使用/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/private%E5%85%B3%E9%94%AE%E5%AD%97%E7%9A%84%E4%BD%BF%E7%94%A8/","excerpt":"private关键字的使用java的三大特性 继承 封装 使用方法就是一种封装 使用private也是一种封装 多态","text":"private关键字的使用java的三大特性 继承 封装 使用方法就是一种封装 使用private也是一种封装 多态 那么什么时候需要使用到private关键字呢？ private是用于需要将某些东西封装起来进行保护，在这种情况下呢，就需要用private关键字进行封装 –黑马 场景一： 假如当我们需要设置一个年龄变量，这里我们先定义一个student类： 123456789public class Student&#123; String name; int age; public void show()&#123; system.out.println(\"我叫：\"+name+\"年龄\"+age+\"岁\") &#125;&#125; 我们再在demo类中调用一下： 12345678910public demo&#123; public static void main(String[]args)&#123; person p = new person(); person.show(); person.name = \"科比\"; person.age = 14; person.show(); &#125;&#125; 显示结果: 我叫科比，今年14岁 但是假如我们需要限制一下年龄，比如年龄不能小于0，这时我们就可以用private进行处理 123456789101112131415161718192021public class Student&#123; String name; private int age; public void show()&#123; System.out.println(\"我叫：\"+name+\"年龄\"+age+\"岁\") &#125; public void setAge(int num)&#123; if num &gt;0&#123; age = num; &#125; else&#123; System.out.println(\"年龄设置错误！\") &#125; &#125; // 这个成员方法专门用于设置age数据 public int getAge()&#123; return age; &#125; // 这个成员方法专门用于获取age数据&#125; 通过间接用getter setter 成员方法，将数据倒手到num，再给age，在num的时候将数据进行一次判断，从而实现。 场景二： 123456789101112public class DemoStudent&#123;public static void main(String[]args)&#123; Student stu = new Student(); stu.SetName(\"鹿晗\"); stu.setAge(18); stu.setMale(true); System.out.println(\"姓名\"+stu.getName()); System.out.println(\"年龄\"+stu.getAgre()); System.out.println(\"是不是爷们？\"+stu.isName()); &#125;&#125; Student类 1234567891011121314151617181920212223242526public class Student&#123; private String name; private int age; private boolean male; public void setName(String str)&#123; name = str; &#125; public void setAge(int num)&#123; age = num; &#125;public void isMale(boolean b)&#123; // 布尔值的setter方法 用的是isxxx male = b; &#125; public String getName()&#123; return name; &#125; public int getAge()&#123; return age; &#125;public boolean getMale()&#123; // 布尔值的getter方法,不变 return male; &#125;&#125; 总结getter和setter的使用方法 getter setter和private一起使用 setter用于设置数据，用于倒手，没有返回值 类型要写void 当数据类型是布尔型的时候，setter的名字改为isXxx setter的方法名格式为setXxx getter的用于获取数据 getter的要return数据，所以类型要和return的类型保持一致 getter的方法名为getXxx 快捷键：Alt+shirt+S 再按R 进行选择","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"Arrays工具类","slug":"Arrays工具类","date":"2020-03-29T05:48:01.494Z","updated":"2020-03-29T06:12:58.052Z","comments":true,"path":"2020/03/29/Arrays工具类/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/Arrays%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"Arrays工具类 java. util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。备注:1.如果是数值，sort默认按照升序从小到大2.如果是字符串，sort默认按照字母升序3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。(今后学习) | public static String toString(数组):将参数数组变成字符串(按照默认格式: [元素1, 元素2,元素3…1) public static void sort(数组): 按照默认升序(从小到大)对数组的元素进行排序。","text":"Arrays工具类 java. util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。备注:1.如果是数值，sort默认按照升序从小到大2.如果是字符串，sort默认按照字母升序3.如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。(今后学习) | public static String toString(数组):将参数数组变成字符串(按照默认格式: [元素1, 元素2,元素3…1) public static void sort(数组): 按照默认升序(从小到大)对数组的元素进行排序。 1234567891011121314import java.util.Arrays;public class Demo01Arrays &#123;public static void main(String[] args) &#123;int[] intArray = &#123;10， 20，30&#125;;//将int[ ]数组按照默认格式变成字符串String intStr = Arrays.toString(intArray);System.out.println(intStr); // [10, 20，30]int[] array1 = &#123;2, 1, 3, 10, 6&#125;;Arrays.sort(array1);System.out.println(Arrays.toString(array1)); // [1, 2, 3, 6, 10]String[] array2 = &#123;\"bbb\"，\"aaa\",\"ccc\"&#125;;Arrays.sort(array2);System.out.println(Arrays.toString(array2)); // [aaa, bbb, ccc]&#125; 实例2 题目:请使用Arrays相关的API，将一个随机字符串中的所有字符升序排列，并倒序打印。 1234567891011121314import java.util.Arrays;public class DemoO2ArraysPractise &#123;public static void main(String[] args) &#123;String str = \"asv76agfqwdfvasdfvjh\" ;//如何进行升序排列:sort//必须是一个数组，才能用Arrays. sort方法// String --&gt;数组，用toCharArraychar[] chars = str. toCharArray();Arrays. sort(chars); //对字符数组进行升序排列//需要倒序遍历for(inti=chars.1ength一1;i&gt;=0;i--)&#123;System.out.println(chars[i]);| &#125;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"String 类","slug":"String 类","date":"2020-03-29T05:48:01.494Z","updated":"2020-03-29T06:10:27.538Z","comments":true,"path":"2020/03/29/String 类/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/String%20%E7%B1%BB/","excerpt":"String 类 String代表字符串类，他存在于java.lang （Java的核心基础类）因此我们之前使用字符串都不用导包 程序当中，所有的双引号“ ”的字符串，都是String类的字符串 字符串的特点 字符串内容永不可变。【重点】 正是因为字符串永不可变，所以字符串是可以共享使用的。 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。 创建字符串常见的3+1种方式（三种构造方法+一种直接创建）： public String(): 创建一个空白字符串，不含任何内容 public String(char[]array): 根据字符数组的内容，来创建对应的字符串。 public String(byte[]array): 根据字节数组的内容，来创建对应的字符串。 String str =&quot;hello&quot;; : 右边直接用双引号 注意：直接用双引号，就是字符串对象，就算你没有new一下，但是系统也会自动帮你new","text":"String 类 String代表字符串类，他存在于java.lang （Java的核心基础类）因此我们之前使用字符串都不用导包 程序当中，所有的双引号“ ”的字符串，都是String类的字符串 字符串的特点 字符串内容永不可变。【重点】 正是因为字符串永不可变，所以字符串是可以共享使用的。 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。 创建字符串常见的3+1种方式（三种构造方法+一种直接创建）： public String(): 创建一个空白字符串，不含任何内容 public String(char[]array): 根据字符数组的内容，来创建对应的字符串。 public String(byte[]array): 根据字节数组的内容，来创建对应的字符串。 String str =&quot;hello&quot;; : 右边直接用双引号 注意：直接用双引号，就是字符串对象，就算你没有new一下，但是系统也会自动帮你new 123456789101112String str =new String();System.out.println(str);char[] charArray = &#123;'a','b','c'&#125;;String str2 = new String(charArray);System.out.println(str2);byte[]byteArray = &#123;97,98,99&#125;;String str3 = new String(byteArray);System.out.println(str3);//直接创建String str4 =\"hello\";System.out.println(str4); 字符串的常量池12345678910char[] charArray = &#123;'a','b','c'&#125;;String str2 = new String(charArray);byte[]byteArray = &#123;97,98,99&#125;;String str3 = new String(byteArray);String str4 =\"abc\";//这样输出判断出来的布尔值是否会相等？？//两个的效果都是输出abcSystem.out.println(str4==str2);System.out.println(str4==str3); 原理： 字符中的常用方法 字符串中的比较方法 ==是进行对象的地址值进行的比较，如果要比较内容，可以用： public boolean equals(Object obj);: 参数可以是任何的对象，只有参数是一个字符串并且内容相同才会给true，否则返回false char[] charArray = {'a','b','c'}; String str2 = new String(charArray); byte[]byteArray = {97,98,99}; String str3 = new String(byteArray); String str4 =\"abc\"; //这样输出判断出来的布尔值是否会相等？？ //两个的效果都是输出abc System.out.println(str4.equals(str2)); //true System.out.println(str2.equals(str3)); //true System.out.println(\"abc\".equals(str2)); //true &lt;!--￼2--&gt; 字符串中的获取方法 public int length();: 获取字符串当中含有的字符串个数，拿到长度 12int length = \"sdafndjsao\".length();System.out.println(\"长度为：\"+length); public String concat(String str);: 将当前的字符串和参数字符串重新拼接成为返回字符串 123456String str1 =\"hello\";String str2 =\"java\";String str3 = str1.concat(str2);System.out.println(str1); //helloSystem.out.println(str2); //javaSystem.out.println(str3); //hellojava public char charAt(int index);: 获取指定索引位置的单个字符 12char ch = \"Hello\".charAt(0);System.out.println(\"在0号位置的字符是\"+ch); public int indexOf(String str);: 查找参数字符串在本字符串中首次出现的位置，如果没有 返回-1 123String str = \"hello\";int index = str.indexOf(\"o\");System.out.println(index); 字符串的截取方法 public String substring(int index);: 截取从参数位置一直到字符串末尾，返回 1234String str =\"mambaforever\"String str1 =str.substring(5);System.out.println(str1); //foreverSystem.out.println(str2); //mambaforever (截取出来不会影响原来的，字符串不可变！) public String substring(int begin,int end); 截取从begin一直到end位置的返回 左闭右开模式 123String str =\"mambaforever\"String str1 =str.substring(4,7);System.out.println(str1); //for 字符串中关于转换的相关方法 public char[ ] tocharArray();: 将当前字符串拆分成为我字符数组作为返回值 1234char [] ch = \"hello\".toCharArray();System.out.println(ch[0]);System.out.println(ch.length);//数组的方法都可以用了 public byte[ ] getBytes();:获得当前字符串底层的字节数组 12byte [] by = \"hello\".toCharArray();System.out.println(by[0]); //会输出h对应的ascll码值 public String replace(CharSequence oldString,CharSequence newString);:将所有出现的老字符串替换成为新的字符串 1234String str = \"how do you do？\"String str1 = str.replace(\"o\",\"*\")// 字符串不能改变的，所有需要新一个的str1来接收System.out.println(str1); 字符串分割的方法 public String[ ] split(String regex);：按照参数的规则，将字符串切分为若干部分 12345String str =\"aaa,bbb,ccc\";String [] array1 = str1.split(\",\");for(int i =0;i&lt;array1.length;i++)&#123; System.out.println(array[i]);&#125; 注意：split的参数是一个正则表达式 经典的实例 – 分析字符串 123456789101112131415161718192021222324public static void main(String[] args) &#123; Scanner sc = new Scanner(System. in); System.out.print1n(\"请输入一个字符串: \"); String input = sc.next(); //获取键盘输入的字符串 int countUpper = 0; //大写字母. int countLower = 0; //小写字母. int countNumber = e; //数字 int countother = 0; //其他字符 char[] charArray = input . toCharArray(); for (int i = 0; i &lt; charArray. length; i++) &#123; char ch = charArray[i]; //当前单个字符 if('A'&lt;=ch&amp;&amp;ch&lt;='Z')&#123; countUpper++; &#125;elseif('a'&lt;=ch&amp;&amp;ch&lt;='z')&#123; count Lower++; &#125;elseif('日'&lt;=ch&amp;&amp;ch&lt;='9')&#123; countNumber++;， &#125;else countOther++; System. out . println(\"大写字母有:”+ countUpper); System. out.println(\"小写字母有:”+ countLower); System. out . println(\"数字有:”+ countNumber); System. out.println(\"其他字符有:”+ countother) ; &#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"ArrayList 类","slug":"ArrayList 类","date":"2020-03-29T05:48:01.484Z","updated":"2020-03-29T06:13:11.004Z","comments":true,"path":"2020/03/29/ArrayList 类/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/ArrayList%20%E7%B1%BB/","excerpt":"ArrayList 类 数组的长度 不可以发生改变，但是ArrayList集合的长度是可以随意发生变化的。 如何使用？ 导包 import java.util.ArrayList; 创建一个ArrayList集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();","text":"ArrayList 类 数组的长度 不可以发生改变，但是ArrayList集合的长度是可以随意发生变化的。 如何使用？ 导包 import java.util.ArrayList; 创建一个ArrayList集合 ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;(); 注意事项： 对于ArrayList来说，有一个 尖括号代表泛型 泛型：就是装在集合当中的所有元素，都是些什么统一的类型 泛型只能是引用类型，不能是基本类型 对于ArrayList来说，直接打印的是内容而不是地址值 如果内容是空的，则直接打印出[ ] ArrayList 的常用方法 public boolean add( E,e); 向集合中添加元素，返回值是布尔值 对于ArrayList集合来说，add添加一定是成功的，返回值可用可不用 但是对于其他集合来说，不一定成功，返回值就很有必要了。 public E remove(int index );从集合中删除元素，参数是索引编号，返回值是删除掉的元素 public E get( int index ); 从集合中获取元素，参数是索引编号，返回值是对应的元素 public int size( ); 获取集合的尺寸长度，返回值是集合中包含的元素个数。 123456789list.add(\"kobe\");list.add(\"curry\");list.add(\"james\");String name = list.get(0);System.out.println(\"0号索引是：\"+name);String whoRemove = list.remove(2);System.out.println(\"被移除掉的是：\"+whoRemove);int size = list.size();System.out.println(\"集合的长度是：\"+size); 遍历数组和遍历集合 1234567for(int i = 0 ;i&lt;array.length;i++)&#123; System.out.println(array[i]);&#125;for(int i = 0 ;i&lt;list.size;i++)&#123; System.out.println(list.get(i));&#125; 遍历数组和遍历集合有所区别，但是类似 如何存放基本类型？ 刚才我们说过，泛型只能是引用类型，不能是基本类型 因为基本类型没有地址值，所以无法存放 如何解决？用基本类型的包装类 基本类型 包装类 byte Byte short Short int Integer(特殊) long Long float Float double Double char Character(特殊) Boolean 使用的时候只需要改成： ArrayList&lt;Integer&gt; listb = new ArraytList&lt;&gt;(); list.add(100); 实例 自定义2个学生对象，添加到集合中，并遍历 思路： 1.自定义Studnet学生类，四个部分 2.创建一个集合，用来存储学生对象，泛型 3.根据类，创建2个学生对象 4.将2个学生对象添加到集合当中 add（）; 5.遍历集合： for size get 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.ArrayList;public class demo &#123; public static void main(String[] args) &#123; ArrayList&lt;Student&gt; list =new ArrayList&lt;&gt;(); Student one = new Student(\"kobe\" ,20); Student two = new Student(\"curry\",18); list.add(one); list.add(two); for(int i = 0 ;i&lt;list.size();i++) &#123; Student1 stu = list.get(i); System.out.println(\"学生名字\"+stu.getAge()+\"学生年龄\"+stu.getName()); &#125; &#125; &#125; class Student&#123; private String name; private int age; Student()&#123; &#125; Student(String name,int age)&#123; this.name = name; this.age = age; &#125; public String getName()&#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public int getAge() &#123; return age; &#125; public void setAge(int age) &#123; this.age = age; &#125; &#125; 数组和集合的区别 数组的效率高于集合类 数组容量固定且无法动态改变，集合类容量动态改变。 数组无法判断其中实际存有多少元素，length只告诉了array的容量。 集合有多种实现方式和不同的适用场合，而不像数组仅采用顺序表方式。 集合以类的形式存在，具有封装、继承、多态等类的特性，通过简单的方法和属性调用 即可实现各种复杂操作，大大提高软件的开发效率。","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]},{"title":"Java算法优化（持续更新）","slug":"算法优化","date":"2020-03-29T05:48:01.467Z","updated":"2020-03-29T06:06:56.123Z","comments":true,"path":"2020/03/29/算法优化/","link":"","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/2020/03/29/%E7%AE%97%E6%B3%95%E4%BC%98%E5%8C%96/","excerpt":"算法优化比较数字大小的算法 题目要求： ​ 比较三个数的大小，并且得到最大值 法一： 123456789101112131415161718192021222324import java.util.Scanner;public class compareNum &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入第一个数字\"); int a = sc.nextInt(); System.out.println(\"请输入第二个数字：\"); int b = sc.nextInt(); System.out.println(\"请输入第三个数字：\"); int c = sc.nextInt(); // 判断方法一 if (a&gt;b&amp;&amp;a&gt;c)&#123; System.out.println(\"最大值为：\"+a); &#125; if (b&gt;a&amp;&amp;b&gt;c)&#123; System.out.println(\"最大值为：\"+b); &#125; if (c&gt;a&amp;&amp;c&gt;b)&#123; System.out.println(\"最大值为：\"+c); &#125; &#125;&#125;","text":"算法优化比较数字大小的算法 题目要求： ​ 比较三个数的大小，并且得到最大值 法一： 123456789101112131415161718192021222324import java.util.Scanner;public class compareNum &#123; public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); System.out.println(\"请输入第一个数字\"); int a = sc.nextInt(); System.out.println(\"请输入第二个数字：\"); int b = sc.nextInt(); System.out.println(\"请输入第三个数字：\"); int c = sc.nextInt(); // 判断方法一 if (a&gt;b&amp;&amp;a&gt;c)&#123; System.out.println(\"最大值为：\"+a); &#125; if (b&gt;a&amp;&amp;b&gt;c)&#123; System.out.println(\"最大值为：\"+b); &#125; if (c&gt;a&amp;&amp;c&gt;b)&#123; System.out.println(\"最大值为：\"+c); &#125; &#125;&#125; 法二： 123int temp =a&gt;b? a:b ;int max = c&gt;temp? c:temp;System.out.println(\"最大值为\"+max); 先通过a和b比较，如果a&gt;b,则把a放入temp，否则把b放入temp； 再比较c和temp，大的赋值给max，最后输出max 法三 12345678int max = a; // 先假定a为最大if(b&gt;max)&#123; max = b;&#125;if(c &gt; max)&#123; max = c;&#125;","categories":[{"name":"Java Notes","slug":"Java-Notes","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/categories/Java-Notes/"}],"tags":[{"name":"java","slug":"java","permalink":"https://github.com/Mamba243/Mamba243.github.io.git/tags/java/"}]}]}